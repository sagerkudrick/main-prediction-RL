<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isotope Box RL - Client Side</title>
    <style>
        .status-text {
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }

        .status-text.success {
            color: #4caf50;
        }

        .button.secondary {
            background-color: #666;
        }

        .button.secondary:hover {
            background-color: #777;
        }
    </style>
    <link rel="stylesheet" href="static/css/style.css">

    <!-- ONNX Runtime Web -->

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/",
            "onnxruntime-web": "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.23.2/dist/ort.min.js"
        }
    }
    </script>
</head>

<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div id="loading-status">Initializing...</div>
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Control Panel -->
    <div id="control-panel">
        <h2>ðŸŽ® Controls</h2>
        <button id="start-btn" class="button">Start</button>
        <button id="stop-btn" class="button danger" disabled>Stop</button>
        <button id="reset-btn" class="button">Reset</button>

        <div class="control-group">
            <label>
                <input type="checkbox" id="rl-enabled-check">
                Enable RL Rotation
            </label>
        </div>

        <div class="control-group">
            <label>Wall Size: <span id="wall-size-val">1.0</span>m</label>
            <input type="range" id="wall-size-slider" min="0.5" max="5.0" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <button id="select-folder-btn" class="button secondary">ðŸ“‚ Select Output Folder</button>
            <div id="folder-status" class="status-text">No folder selected</div>
        </div>

        <button id="save-inference-btn" class="button">ðŸ’¾ Save Inference Image</button>
    </div>

    <!-- Diagnostics -->
    <div id="diagnostics">
        <h2>ðŸ“Š Diagnostics</h2>
        <div class="diagnostic-item">
            <label>Step Count</label>
            <div class="value" id="step-count">0</div>
        </div>
        <div class="diagnostic-item">
            <label>Position [x, y, z]</label>
            <div class="value">
                <span id="pos-x-val">0.00</span>,
                <span id="pos-y-val">0.00</span>,
                <span id="pos-z-val">0.00</span>
            </div>
        </div>
        <div class="diagnostic-item success">
            <label>Predicted Quat</label>
            <div class="value" id="predicted-quat">-</div>
        </div>
        <div class="diagnostic-item">
            <label>Actual Quat</label>
            <div class="value" id="actual-quat">-</div>
        </div>
        <div class="diagnostic-item">
            <label>RL Action</label>
            <div class="value" id="rl-action">-</div>
        </div>

        <div class="diagnostic-item">
            <label>Pred Euler (XYZÂ°)</label>
            <div class="value" id="pred-euler">-</div>
        </div>
        <div class="diagnostic-item">
            <label>Actual Euler (XYZÂ°)</label>
            <div class="value" id="actual-euler">-</div>
        </div>
        <div class="diagnostic-item">
            <label>Quat Angle Distance (Â°)</label>
            <div class="value" id="quat-loss">-</div>
        </div>
        <div class="diagnostic-item">
            <label>Quat Cosine Loss</label>
            <div class="value" id="cos-loss">-</div>
        </div>

    </div>

    <!-- Inference Preview -->
    <div id="image-preview">
        <div class="camera-view">
            <h3>Current Pose (Inference)</h3>
            <canvas id="inference-image"></canvas>
        </div>
        <div class="camera-view">
            <h3>Predicted Pose</h3>
            <canvas id="prediction-image"></canvas>
        </div>
    </div>

    <!-- Error Handler -->
    <script>
        window.onerror = function (msg, url, line, col, error) {
            const status = document.getElementById('loading-status');
            if (status) {
                status.textContent = 'Error: ' + msg;
                status.style.color = 'red';
            }
            console.error('Global error:', msg, error);
            return false;
        };

        window.addEventListener('unhandledrejection', function (event) {
            const status = document.getElementById('loading-status');
            if (status) {
                status.textContent = 'Error: ' + event.reason;
                status.style.color = 'red';
            }
            console.error('Unhandled rejection:', event.reason);
        });
    </script>
    <script src="https://unpkg.com/onnxruntime-web/dist/ort.webgpu.min.js"></script>
    <script type="module">

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PhysicsSimulation } from './static/js/physics.js';
        import { InferenceManager } from './static/js/inference.js';
        import { SimulationController } from './static/js/simulation.js';
        import { addLightHelper } from './static/js/light-helpers.js';
        import { VisualTorqueDebugger } from './static/js/vis_torque.js';

        const INFERENCE_INTERVAL = 5;
        let scene, camera, renderer, controls;
        let crateMesh, inferenceCrate, predictionCrate, wallGroup;
        let inferenceCanvas, inferenceRenderer, inferenceScene, inferenceCamera;
        let predictionCanvas, predictionRenderer, predictionScene, predictionCamera;
        let raycaster, mouse;
        let isDragging = false;
        let debugMesh;
        let torqueDebugger;

        function updateIORAndTransmission(mesh, ior = 1.5, transmission = 1.0) {
            mesh.traverse(node => {
                if (node.isMesh) {
                    const mat = node.material;
                    if (mat && mat.isMeshPhysicalMaterial) {
                        mat.ior = ior;                 // e.g., 1.5 for glass
                        mat.transmission = transmission; // 0..1
                        mat.transparent = true;        // make sure it's transparent
                        mat.needsUpdate = true;        // tell Three.js to recompile shader
                    }
                }
            });
        }


        const simulation = new SimulationController();
        window.simulation = simulation;  // â† ADD THIS LINE
        window.torqueDebugger = null;    // Will be set in loadModel
        // Loading overlay functions
        function updateLoadingStatus(message) {
            const el = document.getElementById('loading-status');
            if (el) el.textContent = message;
        }

        function hideLoadingOverlay() {
            const el = document.getElementById('loading-overlay');
            if (el) {
                el.style.opacity = '0';
                setTimeout(() => {
                    el.style.display = 'none';
                }, 300);
            }
        }

        function quatToEulerDegrees(q) {
            const quat = new THREE.Quaternion(q[0], q[1], q[2], q[3]);
            const e = new THREE.Euler().setFromQuaternion(quat, 'XYZ');
            return [
                THREE.MathUtils.radToDeg(e.x),
                THREE.MathUtils.radToDeg(e.y),
                THREE.MathUtils.radToDeg(e.z)
            ];
        }


        function quaternionAngularDistance(q1, q2) {
            const dot =
                q1[0] * q2[0] +
                q1[1] * q2[1] +
                q1[2] * q2[2] +
                q1[3] * q2[3];

            const d = Math.min(1.0, Math.abs(dot));
            return THREE.MathUtils.radToDeg(2 * Math.acos(d));
        }


        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color('#1a1a2e');

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(3, 1, 3);
            camera.lookAt(0, 0.3, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0.3, 0);

            // Lights
            scene.add(new THREE.AmbientLight(0x404040, 5));
            const dirLight = new THREE.DirectionalLight(0xffffff, 3);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);
            addLightHelper(dirLight, 2, 0xffff00, 0.2);

            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 20),
                new THREE.MeshStandardMaterial({ color: 0x2a2a3e })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = false;
            ground.castShadow = false;
            scene.add(ground);
            scene.add(new THREE.GridHelper(20, 20, 0x667eea, 0x3a3a4e));

            // Placeholder crate
            crateMesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.2, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x667eea })
            );
            crateMesh.castShadow = true;

            scene.add(crateMesh);

            // Initialize raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }

        // Initialize inference scene
        function initInferenceScene() {
            inferenceScene = new THREE.Scene();
            inferenceScene.background = new THREE.Color(0xffffff);

            inferenceCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            inferenceCamera.position.set(0, 0, 3.5);
            inferenceCamera.lookAt(0, 0, 0);

            window.inferenceCamera = inferenceCamera; // for debugging

            inferenceCanvas = document.getElementById('inference-image');
            inferenceCanvas.width = 224;
            inferenceCanvas.height = 224;

            inferenceRenderer = new THREE.WebGLRenderer({
                canvas: inferenceCanvas,
                antialias: true,
                preserveDrawingBuffer: true
            });
            inferenceRenderer.setSize(224, 224);

            // Convert W to Three.js intensity roughly: 1 W â‰ˆ 0.5-1 intensity depending on scene scale
            const intensity = 35; // scaling factor for Three.js, adjust visually

            // Center of your box
            const centerX = (-1.02 + 2.4) / 2; // ~0.69
            const centerY = (3.06 + 3.74) / 2; // ~3.4
            const centerZ = (1.77 + 1.56) / 2; // ~1.665

            // Size of the box
            const sizeX = 2.4 - (-1.02); // 3.42
            const sizeY = 3.74 - 3.06;   // 0.68
            const sizeZ = 1.77 - 1.56;   // 0.21

            // Top light
            const topLight = new THREE.PointLight(0xffffff, intensity, Math.max(sizeX, sizeY, sizeZ) * 2);
            topLight.position.set(centerX + 2, 3.2, centerZ); // slightly above top
            topLight.castShadow = true;

            const inferenceTopLight = topLight.clone();
            scene.add(topLight);

            // Bottom light
            const bottomLight = new THREE.PointLight(0xffffff, intensity * 0.8, Math.max(sizeX, sizeY, sizeZ) * 2);
            bottomLight.position.set(centerX - 1.5, -2, centerZ + 1); // slightly below bottom
            bottomLight.castShadow = true;
            const inferenceBottomLight = bottomLight.clone();
            scene.add(bottomLight);

            window.topLight = topLight
            window.bottomLight = bottomLight

            addLightHelper(topLight, 0.5, 0xffff00, 0.1);
            addLightHelper(bottomLight, 0.5, 0xff00ff, 0.1);

            inferenceTopLight.castShadow = true;
            inferenceBottomLight.castShadow = true;

            inferenceScene.add(inferenceTopLight);
            inferenceScene.add(inferenceBottomLight);

            // Initialize prediction scene (same setup as inference)
            predictionScene = new THREE.Scene();
            predictionScene.background = new THREE.Color(0xffffff);

            predictionCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            predictionCamera.position.set(0, 0, 5.5);
            predictionCamera.lookAt(0, 0, 0);

            predictionCanvas = document.getElementById('prediction-image');
            predictionCanvas.width = 224;
            predictionCanvas.height = 224;

            predictionRenderer = new THREE.WebGLRenderer({
                canvas: predictionCanvas,
                antialias: true,
                preserveDrawingBuffer: true
            });
            predictionRenderer.setSize(224, 224);

            // Clone lights for prediction scene
            const predictionTopLight = topLight.clone();
            predictionTopLight.castShadow = true;
            predictionScene.add(predictionTopLight);

            const predictionBottomLight = bottomLight.clone();
            predictionBottomLight.castShadow = true;
            predictionScene.add(predictionBottomLight);
        }



        // Load GLB model
        function loadModel() {
            const loader = new GLTFLoader();
            loader.load('static/models/engine.glb', (gltf) => {
                if (crateMesh) scene.remove(crateMesh);
                crateMesh = gltf.scene;
                torqueDebugger = new VisualTorqueDebugger(scene, crateMesh);
                window.torqueDebugger = torqueDebugger;

                simulation.onTorqueUpdate = (torque) => {
                    if (torqueDebugger) {
                        torqueDebugger.updateTorque(torque[0], torque[1], torque[2]);
                    }
                };


                window.crateMesh = crateMesh; // for debugging

                // 1. Calculate bounding box
                const box = new THREE.Box3().setFromObject(crateMesh);
                const size = new THREE.Vector3();
                box.getSize(size);
                const center = new THREE.Vector3();
                // 3. Extract and merge ALL geometry for physics
                const allVertices = [];
                const allIndices = [];
                let vertexOffset = 0;

                crateMesh.traverse(node => {
                    if (node.isMesh) {
                        const geo = node.geometry;
                        const pos = geo.attributes.position;

                        // Add vertices (already centered)
                        for (let i = 0; i < pos.count; i++) {
                            allVertices.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                        }

                        // Add indices with offset
                        if (geo.index) {
                            const indices = geo.index.array;
                            for (let i = 0; i < indices.length; i++) {
                                allIndices.push(indices[i] + vertexOffset);
                            }
                        } else {
                            // Non-indexed geometry
                            for (let i = 0; i < pos.count; i++) {
                                allIndices.push(i + vertexOffset);
                            }
                        }

                        vertexOffset += pos.count;

                        console.log(`  Mesh part: ${pos.count} vertices, ${geo.index ? geo.index.count / 3 : pos.count / 3} triangles`);
                    }
                });
                crateMesh.position.set(0, 1.5, 0);

                simulation.setMeshShape(allVertices, allIndices);

                const axes = new THREE.AxesHelper(1.5);
                crateMesh.add(axes);

                crateMesh.scale.set(1.0, 1.0, 1.0);
                crateMesh.traverse(c => {
                    if (c.isMesh) {
                        c.castShadow = true;
                        c.receiveShadow = true;
                    }
                });
                scene.add(crateMesh);

                // 4. Create inference crate - DON'T copy child rotations!
                inferenceCrate = new THREE.Group();
                crateMesh.traverse(node => {
                    if (node.isMesh) {
                        const clone = new THREE.Mesh(node.geometry.clone(), node.material.clone());
                        clone.position.copy(node.position);
                        // DON'T copy rotation - let parent group control it
                        clone.scale.copy(node.scale);
                        inferenceCrate.add(clone);
                    }
                });
                // Apply the base rotation to the group instead
                inferenceScene.add(inferenceCrate);

                // 5. Create prediction crate - DON'T copy child rotations!
                predictionCrate = new THREE.Group();

                window.predictionCrate = predictionCrate; // for debugging

                crateMesh.traverse(node => {
                    if (node.isMesh) {
                        const clone = new THREE.Mesh(node.geometry.clone(), node.material.clone());
                        clone.position.copy(node.position);
                        // DON'T copy rotation - let parent group control it

                        clone.scale.copy(node.scale);
                        predictionCrate.add(clone);
                    }
                });
                // Apply the base rotation to the group instead
                predictionScene.add(predictionCrate);
            });
        }

        function quatCosineLoss(pred, actual) {
            // pred = [x,y,z,w]
            // actual = [x,y,z,w]

            // Normalize (your model normalizes, but safe)
            const np = normQuat(pred);
            const na = normQuat(actual);

            // dot product
            const dot =
                np[0] * na[0] +
                np[1] * na[1] +
                np[2] * na[2] +
                np[3] * na[3];

            // cosine loss from training
            return 1.0 - Math.abs(dot);
        }

        function normQuat(q) {
            const n = Math.sqrt(q[0] ** 2 + q[1] ** 2 + q[2] ** 2 + q[3] ** 2) + 1e-8;
            return [q[0] / n, q[1] / n, q[2] / n, q[3] / n,];
        }


        // UI Controls
        document.getElementById('start-btn').addEventListener('click', () => {
            simulation.start();
            document.getElementById('start-btn').disabled = true;
            document.getElementById('stop-btn').disabled = false;
        });

        document.getElementById('stop-btn').addEventListener('click', () => {
            simulation.stop();
            document.getElementById('start-btn').disabled = false;
            document.getElementById('stop-btn').disabled = true;
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            simulation.reset();
        });

        document.getElementById('rl-enabled-check').addEventListener('change', (e) => {
            simulation.setRLEnabled(e.target.checked);
        });

        document.getElementById('wall-size-slider').addEventListener('input', (e) => {
            const size = parseFloat(e.target.value);
            document.getElementById('wall-size-val').textContent = size.toFixed(1);
            updateWalls(size);
        });

        document.getElementById('save-inference-btn').addEventListener('click', () => {
            window.saveNextInferenceImage = true;
        });

        document.getElementById('select-folder-btn').addEventListener('click', selectOutputFolder);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Simulation callbacks
        simulation.onStateUpdate = (state) => {
            crateMesh.position.set(...state.position);
            crateMesh.quaternion.set(...state.quaternion);

            if (torqueDebugger && state.action) {
                torqueDebugger.updateActionAxes(
                    crateMesh.quaternion,
                    state.action
                );
            }

            // Store for comparison - already in Three.js format
            simulation.lastQuaternion = state.quaternion;

            // Display actual quaternion (Three.js format)
            document.getElementById('actual-quat').textContent =
                `x:${state.quaternion[0].toFixed(3)}, y:${state.quaternion[1].toFixed(3)}, z:${state.quaternion[2].toFixed(3)}, w:${state.quaternion[3].toFixed(3)}`;

            // Display Euler angles
            const euler = quatToEulerDegrees(state.quaternion);
            document.getElementById('actual-euler').textContent =
                `[${euler.map(v => v.toFixed(1)).join(', ')}]`;

            // Update debug mesh
            if (debugMesh) {
                debugMesh.position.copy(crateMesh.position);
                debugMesh.quaternion.copy(crateMesh.quaternion);
            }

            // Update position display
            document.getElementById('pos-x-val').textContent = state.position[0].toFixed(2);
            document.getElementById('pos-y-val').textContent = state.position[1].toFixed(2);
            document.getElementById('pos-z-val').textContent = state.position[2].toFixed(2);
            document.getElementById('step-count').textContent = state.step_count;

            // Update action display
            if (state.action) {
                document.getElementById('rl-action').textContent =
                    `[${state.action.map(v => v.toFixed(3)).join(', ')}]`;
            }
        };

        // Replace the onInferenceUpdate callback:
        simulation.onInferenceUpdate = (result) => {
            const predQuat = result.quaternion; // Already in Three.js format [x,y,z,w]

            // Canonicalize both quaternions for consistent sign comparison
            const predCanonical = canonicalizeQuaternion(predQuat);

            if (!simulation.lastQuaternion) return; // Wait for first physics update
            const actualCanonical = canonicalizeQuaternion(simulation.lastQuaternion);

            // Display predicted quaternion
            document.getElementById('predicted-quat').textContent =
                `x:${predCanonical[0].toFixed(3)}, y:${predCanonical[1].toFixed(3)}, z:${predCanonical[2].toFixed(3)}, w:${predCanonical[3].toFixed(3)}`;

            // Display predicted Euler angles
            const predEuler = quatToEulerDegrees(predCanonical);
            document.getElementById('pred-euler').textContent =
                `[${predEuler.map(v => v.toFixed(1)).join(', ')}]`;

            // Calculate losses using canonical quaternions
            const angle = quaternionAngularDistance(predCanonical, actualCanonical);
            document.getElementById("quat-loss").textContent = angle.toFixed(2);

            const cos = quatCosineLoss(predCanonical, actualCanonical);
            document.getElementById("cos-loss").textContent = cos.toFixed(6);

            const cos_loss = cos.toFixed(6)

            if (cos_loss > 0.036 && cos_loss != NaN) {
                console.log("High Cosine Loss Detected:", cos_loss);
                const timestamp = Date.now();
                const filename = `cam_w${actualCanonical[3].toFixed(3)}_x${actualCanonical[0].toFixed(3)}_y${actualCanonical[1].toFixed(3)}_z${actualCanonical[2].toFixed(3)}_${timestamp}.jpg`;
                console.log("filename: ", filename)
                //saveInferenceImage(filename)
            }

            // Update prediction crate with canonical quaternion
            if (predictionCrate) {
                predictionCrate.quaternion.set(predCanonical[0], predCanonical[1], predCanonical[2], predCanonical[3]);
            }
        };

        let directoryHandle = null;

        async function selectOutputFolder() {
            try {
                directoryHandle = await window.showDirectoryPicker();
                document.getElementById('folder-status').textContent = 'Folder selected: ' + directoryHandle.name;
                document.getElementById('folder-status').classList.add('success');
            } catch (err) {
                console.error('Error selecting folder:', err);
            }
        }

        async function saveInferenceImage(filename) {
            // DO NOT re-render here. The canvas already contains the frame used for inference.
            // Re-rendering might capture a different state if logic changes or if async delays occur.
            // inferenceRenderer.render(inferenceScene, inferenceCamera);

            const canvas = inferenceRenderer.domElement;
            const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.9));

            if (directoryHandle) {
                try {
                    // Save directly to folder
                    const fileHandle = await directoryHandle.getFileHandle(filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    console.log('Saved to folder:', filename);
                } catch (err) {
                    console.error('Error saving to folder:', err);
                    // Fallback to download if saving fails
                    downloadImage(blob, filename);
                }
            } else {
                // Fallback to download
                downloadImage(blob, filename);
            }
        }

        function downloadImage(blob, filename) {
            const dataURL = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename || 'inference.jpg';
            link.click();
            URL.revokeObjectURL(dataURL);
        }

        // Mouse interaction for ragdoll physics
        function getMouseWorldPoint(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (crateMesh) {
                const distance = camera.position.distanceTo(crateMesh.position);
                const worldPoint = new THREE.Vector3();
                worldPoint.copy(raycaster.ray.origin).add(
                    raycaster.ray.direction.clone().multiplyScalar(distance)
                );
                return [worldPoint.x, worldPoint.y, worldPoint.z];
            }
            return null;
        }

        function initInput() {
            renderer.domElement.addEventListener('mousedown', (event) => {
                if (!simulation.isRunning) return;

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(crateMesh, true);

                if (intersects.length > 0) {
                    isDragging = true;
                    controls.enabled = false;
                    const point = intersects[0].point;
                    simulation.grabBox([point.x, point.y, point.z]);
                }
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                const worldPoint = getMouseWorldPoint(event);
                if (worldPoint) {
                    simulation.moveGrabbed(worldPoint);
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    controls.enabled = true;
                    simulation.releaseBox();
                }
            });

            renderer.domElement.addEventListener('mouseleave', () => {
                if (isDragging) {
                    isDragging = false;
                    controls.enabled = true;
                    simulation.releaseBox();
                }
            });
        }

        // Fixed Time Step Logic
        let lastTime = performance.now();
        let accumulator = 0;
        const FIXED_TIME_STEP = 1 / 60; // Simulate 60 physics steps per second (real-time)

        // Animation loop
        async function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            let frameTime = (now - lastTime) / 1000; // Seconds
            lastTime = now;

            // Cap frameTime to prevent spiral of death if tab is backgrounded
            if (frameTime > 0.25) frameTime = 0.25;

            accumulator += frameTime;

            if (simulation.isRunning && inferenceCrate && predictionCrate) {
                // Update inference crate to match current pose BEFORE rendering
                inferenceCrate.position.set(0, 0, 0);
                inferenceCrate.quaternion.copy(crateMesh.quaternion);
                inferenceCrate.scale.copy(crateMesh.scale);

                // Render inference scene BEFORE capturing for inference
                inferenceRenderer.render(inferenceScene, inferenceCamera);

                // Update prediction crate position (rotation is set by onInferenceUpdate)
                predictionCrate.position.set(0, 0, 0);
                predictionCrate.scale.copy(crateMesh.scale);

                // Render prediction scene
                predictionRenderer.render(predictionScene, predictionCamera);

                // Fixed Time Step Simulation Loop
                // Ensures physics runs at exactly 1x speed regardless of FPS (60hz, 144hz, etc)
                while (accumulator >= FIXED_TIME_STEP) {
                    await simulation.step(inferenceRenderer, INFERENCE_INTERVAL);
                    accumulator -= FIXED_TIME_STEP;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }


        function canonicalizeQuaternion(q) {
            // Prefer w > 0 (or x > 0 if w == 0) for consistent sign
            if (q[3] < 0 || (q[3] === 0 && q[0] < 0)) {
                return [-q[0], -q[1], -q[2], -q[3]];
            }
            return [q[0], q[1], q[2], q[3]];
        }

        // Initialize
        async function init() {
            try {
                updateLoadingStatus('Initializing scene...');
                initScene();
                initInferenceScene();
                initInput();
                loadModel();

                updateLoadingStatus('Loading ONNX models...');
                await simulation.initialize();

                updateLoadingStatus('Ready!');
                hideLoadingOverlay();

                animate();
            } catch (error) {
                console.error('Initialization error:', error);
                updateLoadingStatus('Error: ' + error.message);
            }
        }

        init();
    </script>
</body>

</html>