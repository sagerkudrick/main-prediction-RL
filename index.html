<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isotope Box RL - Client Side</title>
    <link rel="stylesheet" href="static/css/style.css">

    <!-- ONNX Runtime Web -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.min.js"></script>

    <!-- Cannon.js Physics -->
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/",
            "onnxruntime-web": "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.min.js"
        }
    }
    </script>
</head>

<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div id="loading-status">Initializing...</div>
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Control Panel -->
    <div id="control-panel">
        <h2>ðŸŽ® Controls</h2>
        <button id="start-btn" class="button">Start</button>
        <button id="stop-btn" class="button danger" disabled>Stop</button>
        <button id="reset-btn" class="button">Reset</button>

        <div class="control-group">
            <label>
                <input type="checkbox" id="rl-enabled-check">
                Enable RL Rotation
            </label>
        </div>

        <div class="control-group">
            <label>Wall Size: <span id="wall-size-val">1.0</span>m</label>
            <input type="range" id="wall-size-slider" min="0.5" max="5.0" step="0.1" value="1.0">
        </div>
    </div>

    <!-- Diagnostics -->
    <div id="diagnostics">
        <h2>ðŸ“Š Diagnostics</h2>
        <div class="diagnostic-item">
            <label>Step Count</label>
            <div class="value" id="step-count">0</div>
        </div>
        <div class="diagnostic-item">
            <label>Position [x, y, z]</label>
            <div class="value">
                <span id="pos-x-val">0.00</span>,
                <span id="pos-y-val">0.00</span>,
                <span id="pos-z-val">0.00</span>
            </div>
        </div>
        <div class="diagnostic-item success">
            <label>Predicted Quat</label>
            <div class="value" id="predicted-quat">-</div>
        </div>
        <div class="diagnostic-item">
            <label>Actual Quat</label>
            <div class="value" id="actual-quat">-</div>
        </div>
        <div class="diagnostic-item">
            <label>RL Action</label>
            <div class="value" id="rl-action">-</div>
        </div>
    </div>

    <!-- Inference Preview -->
    <div id="image-preview">
        <h3>Inference Camera</h3>
        <canvas id="inference-image"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PhysicsSimulation } from './static/js/physics.js';
        import { InferenceManager } from './static/js/inference.js';
        import { SimulationController } from './static/js/simulation.js';

        const INFERENCE_INTERVAL = 15;

        let scene, camera, renderer, controls;
        let crateMesh, inferenceCrate, wallGroup;
        let inferenceCanvas, inferenceRenderer, inferenceScene, inferenceCamera;

        const simulation = new SimulationController();

        // Loading overlay functions
        function updateLoadingStatus(message) {
            document.getElementById('loading-status').textContent = message;
        }

        function hideLoadingOverlay() {
            document.getElementById('loading-overlay').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-overlay').style.display = 'none';
            }, 300);
        }

        function captureInferenceImage(renderer, width = 256, height = 256) {
            const gl = renderer.getContext();
            const pixels = new Uint8Array(width * height * 4); // RGBA
            gl.readPixels(
                0, 0, width, height,
                gl.RGBA, gl.UNSIGNED_BYTE,
                pixels
            );

            // Flip Y-axis because WebGL origin is bottom-left
            const flipped = new Uint8Array(width * height * 4);
            for (let y = 0; y < height; y++) {
                const srcOffset = y * width * 4;
                const destOffset = (height - 1 - y) * width * 4;
                flipped.set(pixels.subarray(srcOffset, srcOffset + width * 4), destOffset);
            }

            return flipped;
        }

        function pixelsToTensor(pixels, width = 256, height = 256) {
            const data = new Float32Array(3 * width * height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    // Normalize to 0..1 and separate channels
                    data[y * width + x] = pixels[i] / 255;               // R
                    data[width * height + y * width + x] = pixels[i + 1] / 255; // G
                    data[2 * width * height + y * width + x] = pixels[i + 2] / 255; // B
                }
            }

            return new ort.Tensor('float32', data, [1, 3, height, width]);
        }

        async function runInference(session, renderer) {
            // 1. Capture the image
            const pixels = captureInferenceImage(renderer);

            // 2. Convert to tensor
            const inputTensor = pixelsToTensor(pixels);

            // 3. Run ONNX model
            const feeds = { input: inputTensor }; // adjust key name to your model
            const output = await session.run(feeds);

            return output;
        }


        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color('#1a1a2e');

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(3, 1, 3);
            camera.lookAt(0, 0.3, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0.3, 0);

            // Lights
            scene.add(new THREE.AmbientLight(0x404040, 2));
            const dirLight = new THREE.DirectionalLight(0xffffff, 3);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 20),
                new THREE.MeshStandardMaterial({ color: 0x2a2a3e })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            scene.add(new THREE.GridHelper(20, 20, 0x667eea, 0x3a3a4e));

            // Placeholder crate
            crateMesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.2, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x667eea })
            );
            crateMesh.castShadow = true;
            scene.add(crateMesh);
        }

        // Initialize inference scene
        function initInferenceScene() {
            inferenceScene = new THREE.Scene();
            inferenceScene.background = new THREE.Color(0xffffff);

            inferenceCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            inferenceCamera.position.set(0, 0, 0.3);
            inferenceCamera.lookAt(0, 0, 0);

            window.inferenceCamera = inferenceCamera; // for debugging

            inferenceCanvas = document.getElementById('inference-image');
            inferenceCanvas.width = 224;
            inferenceCanvas.height = 224;

            inferenceRenderer = new THREE.WebGLRenderer({
                canvas: inferenceCanvas,
                antialias: true,
                preserveDrawingBuffer: true
            });
            inferenceRenderer.setSize(224, 224);

            inferenceScene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(2, 3, 2);
            inferenceScene.add(light);
        }

        // Load GLB model
        function loadModel() {
            const loader = new GLTFLoader();
            loader.load('static/models/isotopebox.glb', (gltf) => {
                if (crateMesh) scene.remove(crateMesh);
                crateMesh = gltf.scene;
                window.crateMesh = crateMesh; // for debugging

                const box = new THREE.Box3().setFromObject(crateMesh);
                window.box = box;
                console.log(box.min.y);

                crateMesh.scale.set(0.1, 0.1, 0.1);
                crateMesh.traverse(c => {
                    if (c.isMesh) {
                        c.castShadow = true;
                        c.receiveShadow = true;
                    }
                });
                scene.add(crateMesh);

                // Create inference crate
                inferenceCrate = new THREE.Group();
                crateMesh.traverse(node => {
                    if (node.isMesh) {
                        const clone = new THREE.Mesh(node.geometry.clone(), node.material.clone());
                        clone.position.copy(node.position);
                        clone.rotation.copy(node.rotation);
                        clone.scale.copy(node.scale);
                        inferenceCrate.add(clone);
                    }
                });
                scene.add(inferenceCrate);
                const box1 = new THREE.Box3().setFromObject(crateMesh);
                const helper = new THREE.Box3Helper(box1, 0xff0000); // red outline
                scene.add(helper);
            });
        }

        // Simulation callbacks
        simulation.onStateUpdate = (state) => {
            crateMesh.position.set(...state.position);
            crateMesh.quaternion.set(...state.quaternion);

            document.getElementById('pos-x-val').textContent = state.position[0].toFixed(2);
            document.getElementById('pos-y-val').textContent = state.position[1].toFixed(2);
            document.getElementById('pos-z-val').textContent = state.position[2].toFixed(2);
            document.getElementById('step-count').textContent = state.step_count;
            document.getElementById('actual-quat').textContent =
                `[${state.quaternion.map(v => v.toFixed(3)).join(', ')}]`;

            if (state.action) {
                document.getElementById('rl-action').textContent =
                    `[${state.action.map(v => v.toFixed(3)).join(', ')}]`;
            }
        };

        simulation.onInferenceUpdate = (result) => {
            document.getElementById('predicted-quat').textContent =
                `[${result.quaternion.map(v => v.toFixed(3)).join(', ')}]`;
        };

        // Animation loop
        async function animate() {
            requestAnimationFrame(animate);

            if (simulation.isRunning && inferenceCrate) {
                await simulation.step(inferenceCanvas, INFERENCE_INTERVAL);

                inferenceCrate.position.copy(crateMesh.position);
                inferenceCrate.quaternion.copy(crateMesh.quaternion);
                inferenceCrate.scale.copy(crateMesh.scale);

                box1.position.copy(crateMesh.position);
                box1.quaternion.copy(crateMesh.quaternion);
                box1.scale.copy(crateMesh.scale);

                inferenceRenderer.render(inferenceScene, inferenceCamera);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // UI Controls
        document.getElementById('start-btn').addEventListener('click', () => {
            simulation.start();
            document.getElementById('start-btn').disabled = true;
            document.getElementById('stop-btn').disabled = false;
        });

        document.getElementById('stop-btn').addEventListener('click', () => {
            simulation.stop();
            document.getElementById('start-btn').disabled = false;
            document.getElementById('stop-btn').disabled = true;
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            simulation.reset();
        });

        document.getElementById('rl-enabled-check').addEventListener('change', (e) => {
            simulation.setRLEnabled(e.target.checked);
        });

        document.getElementById('wall-size-slider').addEventListener('input', (e) => {
            const size = parseFloat(e.target.value);
            document.getElementById('wall-size-val').textContent = size.toFixed(1);
            simulation.updateWalls(size);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        async function init() {
            try {
                updateLoadingStatus('Initializing scene...');
                initScene();
                initInferenceScene();
                loadModel();

                updateLoadingStatus('Loading ONNX models...');
                await simulation.initialize();

                updateLoadingStatus('Ready!');
                hideLoadingOverlay();

                animate();
            } catch (error) {
                console.error('Initialization error:', error);
                updateLoadingStatus('Error: ' + error.message);
            }
        }

        init();
    </script>
</body>

</html>