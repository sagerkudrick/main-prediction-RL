<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isotope Box RL - Client Side</title>
    <link rel="stylesheet" href="static/css/style.css">

    <!-- ONNX Runtime Web -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.min.js"></script>

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/",
            "onnxruntime-web": "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.min.js"
        }
    }
    </script>
</head>

<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div id="loading-status">Initializing...</div>
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Control Panel -->
    <div id="control-panel">
        <h2>ðŸŽ® Controls</h2>
        <button id="start-btn" class="button">Start</button>
        <button id="stop-btn" class="button danger" disabled>Stop</button>
        <button id="reset-btn" class="button">Reset</button>

        <div class="control-group">
            <label>
                <input type="checkbox" id="rl-enabled-check">
                Enable RL Rotation
            </label>
        </div>

        <div class="control-group">
            <label>Wall Size: <span id="wall-size-val">1.0</span>m</label>
            <input type="range" id="wall-size-slider" min="0.5" max="5.0" step="0.1" value="1.0">
        </div>
    </div>

    <!-- Diagnostics -->
    <div id="diagnostics">
        <h2>ðŸ“Š Diagnostics</h2>
        <div class="diagnostic-item">
            <label>Step Count</label>
            <div class="value" id="step-count">0</div>
        </div>
        <div class="diagnostic-item">
            <label>Position [x, y, z]</label>
            <div class="value">
                <span id="pos-x-val">0.00</span>,
                <span id="pos-y-val">0.00</span>,
                <span id="pos-z-val">0.00</span>
            </div>
        </div>
        <div class="diagnostic-item success">
            <label>Predicted Quat</label>
            <div class="value" id="predicted-quat">-</div>
        </div>
        <div class="diagnostic-item">
            <label>Actual Quat</label>
            <div class="value" id="actual-quat">-</div>
        </div>
        <div class="diagnostic-item">
            <label>RL Action</label>
            <div class="value" id="rl-action">-</div>
        </div>
    </div>

    <!-- Inference Preview -->
    <div id="image-preview">
        <h3>Inference Camera</h3>
        <canvas id="inference-image"></canvas>
    </div>

    <!-- Error Handler -->
    <script>
        window.onerror = function (msg, url, line, col, error) {
            const status = document.getElementById('loading-status');
            if (status) {
                status.textContent = 'Error: ' + msg;
                status.style.color = 'red';
            }
            console.error('Global error:', msg, error);
            return false;
        };

        window.addEventListener('unhandledrejection', function (event) {
            const status = document.getElementById('loading-status');
            if (status) {
                status.textContent = 'Error: ' + event.reason;
                status.style.color = 'red';
            }
            console.error('Unhandled rejection:', event.reason);
        });
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PhysicsSimulation } from './static/js/physics.js';
        import { InferenceManager } from './static/js/inference.js';
        import { SimulationController } from './static/js/simulation.js';

        const INFERENCE_INTERVAL = 15;

        let scene, camera, renderer, controls;
        let crateMesh, inferenceCrate, wallGroup;
        let inferenceCanvas, inferenceRenderer, inferenceScene, inferenceCamera;
        let raycaster, mouse;
        let isDragging = false;

        const simulation = new SimulationController();

        // Loading overlay functions
        function updateLoadingStatus(message) {
            const el = document.getElementById('loading-status');
            if (el) el.textContent = message;
        }

        function hideLoadingOverlay() {
            const el = document.getElementById('loading-overlay');
            if (el) {
                el.style.opacity = '0';
                setTimeout(() => {
                    el.style.display = 'none';
                }, 300);
            }
        }

        function captureInferenceImage(renderer, width = 256, height = 256) {
            const gl = renderer.getContext();
            const pixels = new Uint8Array(width * height * 4); // RGBA
            gl.readPixels(
                0, 0, width, height,
                gl.RGBA, gl.UNSIGNED_BYTE,
                pixels
            );

            // Flip Y-axis because WebGL origin is bottom-left
            const flipped = new Uint8Array(width * height * 4);
            for (let y = 0; y < height; y++) {
                const srcOffset = y * width * 4;
                const destOffset = (height - 1 - y) * width * 4;
                flipped.set(pixels.subarray(srcOffset, srcOffset + width * 4), destOffset);
            }

            return flipped;
        }

        function pixelsToTensor(pixels, width = 256, height = 256) {
            const data = new Float32Array(3 * width * height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    // Normalize to 0..1 and separate channels
                    data[y * width + x] = pixels[i] / 255;               // R
                    data[width * height + y * width + x] = pixels[i + 1] / 255; // G
                    data[2 * width * height + y * width + x] = pixels[i + 2] / 255; // B
                }
            }

            return new ort.Tensor('float32', data, [1, 3, height, width]);
        }

        async function runInference(session, renderer) {
            // 1. Capture the image
            const pixels = captureInferenceImage(renderer);

            // 2. Convert to tensor
            const inputTensor = pixelsToTensor(pixels);

            // 3. Run ONNX model
            const feeds = { input: inputTensor }; // adjust key name to your model
            const output = await session.run(feeds);

            return output;
        }


        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color('#1a1a2e');

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(3, 1, 3);
            camera.lookAt(0, 0.3, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0.3, 0);

            // Lights
            scene.add(new THREE.AmbientLight(0x404040, 2));
            const dirLight = new THREE.DirectionalLight(0xffffff, 3);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 20),
                new THREE.MeshStandardMaterial({ color: 0x2a2a3e })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            scene.add(new THREE.GridHelper(20, 20, 0x667eea, 0x3a3a4e));

            // Placeholder crate
            crateMesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.2, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x667eea })
            );
            crateMesh.castShadow = true;
            scene.add(crateMesh);

            // Initialize raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }

        // Initialize inference scene
        function initInferenceScene() {
            inferenceScene = new THREE.Scene();
            inferenceScene.background = new THREE.Color(0xffffff);

            inferenceCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            inferenceCamera.position.set(0, 0, 0.3);
            inferenceCamera.lookAt(0, 0, 0);

            window.inferenceCamera = inferenceCamera; // for debugging

            inferenceCanvas = document.getElementById('inference-image');
            inferenceCanvas.width = 224;
            inferenceCanvas.height = 224;

            inferenceRenderer = new THREE.WebGLRenderer({
                canvas: inferenceCanvas,
                antialias: true,
                preserveDrawingBuffer: true
            });
            inferenceRenderer.setSize(224, 224);

            inferenceScene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(2, 3, 2);
            inferenceScene.add(light);
        }

        // Create visual walls matching physics
        function createWalls(size) {
            // Remove existing walls
            if (wallGroup) {
                scene.remove(wallGroup);
            }

            wallGroup = new THREE.Group();
            const halfSize = size / 1.0;
            const height = 0.5;
            const thickness = 0.05;

            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x667eea,
                transparent: true,
                opacity: 0.3
            });

            // North wall (Z-)
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(halfSize * 2 + thickness * 2, height * 2, thickness * 2),
                wallMaterial
            );
            northWall.position.set(0, height, -halfSize - thickness);
            wallGroup.add(northWall);

            // South wall (Z+)
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(halfSize * 2 + thickness * 2, height * 2, thickness * 2),
                wallMaterial
            );
            southWall.position.set(0, height, halfSize + thickness);
            wallGroup.add(southWall);

            // East wall (X+)
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(thickness * 2, height * 2, halfSize * 2),
                wallMaterial
            );
            eastWall.position.set(halfSize + thickness, height, 0);
            wallGroup.add(eastWall);

            // West wall (X-)
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(thickness * 2, height * 2, halfSize * 2),
                wallMaterial
            );
            westWall.position.set(-halfSize - thickness, height, 0);
            wallGroup.add(westWall);

            scene.add(wallGroup);
        }

        // Update walls when size changes
        function updateWalls(size) {
            createWalls(size);
            simulation.updateWalls(size);
        }

        // Load GLB model
        function loadModel() {
            const loader = new GLTFLoader();
            loader.load('static/models/isotopebox.glb', (gltf) => {
                if (crateMesh) scene.remove(crateMesh);
                crateMesh = gltf.scene;
                window.crateMesh = crateMesh; // for debugging

                const box = new THREE.Box3().setFromObject(crateMesh);
                const size = new THREE.Vector3();
                box.getSize(size);

                // Update physics box size (half-extents)
                simulation.setBoxSize(size.x / 2, size.y / 2, size.z / 2);

                console.log(`Model loaded. Size: ${size.x.toFixed(3)} x ${size.y.toFixed(3)} x ${size.z.toFixed(3)}`);

                crateMesh.scale.set(1.0, 1.0, 1.0);
                crateMesh.traverse(c => {
                    if (c.isMesh) {
                        c.castShadow = true;
                        c.receiveShadow = true;
                    }
                });
                scene.add(crateMesh);

                // Create inference crate
                inferenceCrate = new THREE.Group();
                crateMesh.traverse(node => {
                    if (node.isMesh) {
                        const clone = new THREE.Mesh(node.geometry.clone(), node.material.clone());
                        clone.position.copy(node.position);
                        clone.rotation.copy(node.rotation);
                        clone.scale.copy(node.scale);
                        inferenceCrate.add(clone);
                    }
                });
                inferenceScene.add(inferenceCrate);
            });
        }

        // Simulation callbacks
        simulation.onStateUpdate = (state) => {
            crateMesh.position.set(...state.position);
            crateMesh.quaternion.set(...state.quaternion);

            document.getElementById('pos-x-val').textContent = state.position[0].toFixed(2);
            document.getElementById('pos-y-val').textContent = state.position[1].toFixed(2);
            document.getElementById('pos-z-val').textContent = state.position[2].toFixed(2);
            document.getElementById('step-count').textContent = state.step_count;
            document.getElementById('actual-quat').textContent =
                `[${state.quaternion.map(v => v.toFixed(3)).join(', ')}]`;

            if (state.action) {
                document.getElementById('rl-action').textContent =
                    `[${state.action.map(v => v.toFixed(3)).join(', ')}]`;
            }
        };

        simulation.onInferenceUpdate = (result) => {
            document.getElementById('predicted-quat').textContent =
                `[${result.quaternion.map(v => v.toFixed(3)).join(', ')}]`;
        };

        // Animation loop
        async function animate() {
            requestAnimationFrame(animate);

            if (simulation.isRunning && inferenceCrate) {
                await simulation.step(inferenceCanvas, INFERENCE_INTERVAL);

                inferenceCrate.position.set(0, 0, 0);
                inferenceCrate.quaternion.copy(crateMesh.quaternion);
                inferenceCrate.scale.copy(crateMesh.scale);

                inferenceRenderer.render(inferenceScene, inferenceCamera);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // UI Controls
        document.getElementById('start-btn').addEventListener('click', () => {
            simulation.start();
            document.getElementById('start-btn').disabled = true;
            document.getElementById('stop-btn').disabled = false;
        });

        document.getElementById('stop-btn').addEventListener('click', () => {
            simulation.stop();
            document.getElementById('start-btn').disabled = false;
            document.getElementById('stop-btn').disabled = true;
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            simulation.reset();
        });

        document.getElementById('rl-enabled-check').addEventListener('change', (e) => {
            simulation.setRLEnabled(e.target.checked);
        });

        document.getElementById('wall-size-slider').addEventListener('input', (e) => {
            const size = parseFloat(e.target.value);
            document.getElementById('wall-size-val').textContent = size.toFixed(1);
            updateWalls(size);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Mouse interaction for ragdoll physics
        function getMouseWorldPoint(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (crateMesh) {
                const distance = camera.position.distanceTo(crateMesh.position);
                const worldPoint = new THREE.Vector3();
                worldPoint.copy(raycaster.ray.origin).add(
                    raycaster.ray.direction.clone().multiplyScalar(distance)
                );
                return [worldPoint.x, worldPoint.y, worldPoint.z];
            }
            return null;
        }

        function initInput() {
            renderer.domElement.addEventListener('mousedown', (event) => {
                if (!simulation.isRunning) return;

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(crateMesh, true);

                if (intersects.length > 0) {
                    isDragging = true;
                    controls.enabled = false;
                    const point = intersects[0].point;
                    simulation.grabBox([point.x, point.y, point.z]);
                }
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                const worldPoint = getMouseWorldPoint(event);
                if (worldPoint) {
                    simulation.moveGrabbed(worldPoint);
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    controls.enabled = true;
                    simulation.releaseBox();
                }
            });

            renderer.domElement.addEventListener('mouseleave', () => {
                if (isDragging) {
                    isDragging = false;
                    controls.enabled = true;
                    simulation.releaseBox();
                }
            });
        }

        // Initialize
        async function init() {
            try {
                updateLoadingStatus('Initializing scene...');
                initScene();
                initInferenceScene();
                initInput(); // Initialize input listeners after renderer is ready
                loadModel();
                createWalls(1.0); // Initialize walls with default size

                updateLoadingStatus('Loading ONNX models...');
                await simulation.initialize();

                updateLoadingStatus('Ready!');
                hideLoadingOverlay();

                animate();
            } catch (error) {
                console.error('Initialization error:', error);
                updateLoadingStatus('Error: ' + error.message);
            }
        }

        init();
    </script>
</body>

</html>