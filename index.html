<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isotope Box RL - Client Side</title>
    <link rel="stylesheet" href="static/css/style.css">

    <!-- ONNX Runtime Web -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.min.js"></script>

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/",
            "onnxruntime-web": "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.min.js"
        }
    }
    </script>
</head>

<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div id="loading-status">Initializing...</div>
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Control Panel -->
    <div id="control-panel">
        <h2>ðŸŽ® Controls</h2>
        <button id="start-btn" class="button">Start</button>
        <button id="stop-btn" class="button danger" disabled>Stop</button>
        <button id="reset-btn" class="button">Reset</button>

        <div class="control-group">
            <label>
                <input type="checkbox" id="rl-enabled-check">
                Enable RL Rotation
            </label>
        </div>

        <div class="control-group">
            <label>Wall Size: <span id="wall-size-val">1.0</span>m</label>
            <input type="range" id="wall-size-slider" min="0.5" max="5.0" step="0.1" value="1.0">
        </div>

        <button id="save-inference-btn" class="button">ðŸ’¾ Save Inference Image</button>
    </div>

    <!-- Diagnostics -->
    <div id="diagnostics">
        <h2>ðŸ“Š Diagnostics</h2>
        <div class="diagnostic-item">
            <label>Step Count</label>
            <div class="value" id="step-count">0</div>
        </div>
        <div class="diagnostic-item">
            <label>Position [x, y, z]</label>
            <div class="value">
                <span id="pos-x-val">0.00</span>,
                <span id="pos-y-val">0.00</span>,
                <span id="pos-z-val">0.00</span>
            </div>
        </div>
        <div class="diagnostic-item success">
            <label>Predicted Quat</label>
            <div class="value" id="predicted-quat">-</div>
        </div>
        <div class="diagnostic-item">
            <label>Actual Quat</label>
            <div class="value" id="actual-quat">-</div>
        </div>
        <div class="diagnostic-item">
            <label>RL Action</label>
            <div class="value" id="rl-action">-</div>
        </div>

        <div class="diagnostic-item">
            <label>Pred Euler (XYZÂ°)</label>
            <div class="value" id="pred-euler">-</div>
        </div>
        <div class="diagnostic-item">
            <label>Actual Euler (XYZÂ°)</label>
            <div class="value" id="actual-euler">-</div>
        </div>
        <div class="diagnostic-item">
            <label>Quat Angle Distance (Â°)</label>
            <div class="value" id="quat-loss">-</div>
        </div>
        <div class="diagnostic-item">
            <label>Quat Cosine Loss</label>
            <div class="value" id="cos-loss">-</div>
        </div>

    </div>

    <!-- Inference Preview -->
    <div id="image-preview">
        <div class="camera-view">
            <h3>Current Pose (Inference)</h3>
            <canvas id="inference-image"></canvas>
        </div>
        <div class="camera-view">
            <h3>Predicted Pose</h3>
            <canvas id="prediction-image"></canvas>
        </div>
    </div>

    <!-- Error Handler -->
    <script>
        window.onerror = function (msg, url, line, col, error) {
            const status = document.getElementById('loading-status');
            if (status) {
                status.textContent = 'Error: ' + msg;
                status.style.color = 'red';
            }
            console.error('Global error:', msg, error);
            return false;
        };

        window.addEventListener('unhandledrejection', function (event) {
            const status = document.getElementById('loading-status');
            if (status) {
                status.textContent = 'Error: ' + event.reason;
                status.style.color = 'red';
            }
            console.error('Unhandled rejection:', event.reason);
        });
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PhysicsSimulation } from './static/js/physics.js';
        import { InferenceManager } from './static/js/inference.js';
        import { SimulationController } from './static/js/simulation.js';
        import { addLightHelper } from './static/js/light-helpers.js';

        const INFERENCE_INTERVAL = 5;

        let scene, camera, renderer, controls;
        let crateMesh, inferenceCrate, predictionCrate, wallGroup;
        let inferenceCanvas, inferenceRenderer, inferenceScene, inferenceCamera;
        let predictionCanvas, predictionRenderer, predictionScene, predictionCamera;
        let raycaster, mouse;
        let isDragging = false;
        let debugMesh;

        const simulation = new SimulationController();

        // Loading overlay functions
        function updateLoadingStatus(message) {
            const el = document.getElementById('loading-status');
            if (el) el.textContent = message;
        }

        function hideLoadingOverlay() {
            const el = document.getElementById('loading-overlay');
            if (el) {
                el.style.opacity = '0';
                setTimeout(() => {
                    el.style.display = 'none';
                }, 300);
            }
        }

        function quatToEulerDegrees(q) {
            const quat = new THREE.Quaternion(q[0], q[1], q[2], q[3]);
            const e = new THREE.Euler().setFromQuaternion(quat, 'XYZ');
            return [
                THREE.MathUtils.radToDeg(e.x),
                THREE.MathUtils.radToDeg(e.y),
                THREE.MathUtils.radToDeg(e.z)
            ];
        }


        function quaternionAngularDistance(q1, q2) {
            const dot =
                q1[0] * q2[0] +
                q1[1] * q2[1] +
                q1[2] * q2[2] +
                q1[3] * q2[3];

            const d = Math.min(1.0, Math.abs(dot));
            return THREE.MathUtils.radToDeg(2 * Math.acos(d));
        }


        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color('#1a1a2e');

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(3, 1, 3);
            camera.lookAt(0, 0.3, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0.3, 0);

            // Lights
            // scene.add(new THREE.AmbientLight(0x404040, 2));
            // const dirLight = new THREE.DirectionalLight(0xffffff, 3);
            // dirLight.position.set(5, 10, 5);
            // dirLight.castShadow = true;
            // scene.add(dirLight);
            // addLightHelper(dirLight, 2, 0xffff00, 0.2);

            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 20),
                new THREE.MeshStandardMaterial({ color: 0x2a2a3e })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = false;
            ground.castShadow = false;
            scene.add(ground);
            scene.add(new THREE.GridHelper(20, 20, 0x667eea, 0x3a3a4e));

            // Placeholder crate
            crateMesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.2, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x667eea })
            );
            crateMesh.castShadow = true;

            scene.add(crateMesh);

            // Initialize raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }

        // Initialize inference scene
        function initInferenceScene() {
            inferenceScene = new THREE.Scene();
            inferenceScene.background = new THREE.Color(0xffffff);

            inferenceCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            inferenceCamera.position.set(0, 0, 3);
            inferenceCamera.lookAt(0, 0, 0);

            window.inferenceCamera = inferenceCamera; // for debugging

            inferenceCanvas = document.getElementById('inference-image');
            inferenceCanvas.width = 224;
            inferenceCanvas.height = 224;

            inferenceRenderer = new THREE.WebGLRenderer({
                canvas: inferenceCanvas,
                antialias: true,
                preserveDrawingBuffer: true
            });
            inferenceRenderer.setSize(224, 224);

            // Convert W to Three.js intensity roughly: 1 W â‰ˆ 0.5-1 intensity depending on scene scale
            const intensity = 35; // scaling factor for Three.js, adjust visually

            // Center of your box
            const centerX = (-1.02 + 2.4) / 2; // ~0.69
            const centerY = (3.06 + 3.74) / 2; // ~3.4
            const centerZ = (1.77 + 1.56) / 2; // ~1.665

            // Size of the box
            const sizeX = 2.4 - (-1.02); // 3.42
            const sizeY = 3.74 - 3.06;   // 0.68
            const sizeZ = 1.77 - 1.56;   // 0.21

            // Top light
            const topLight = new THREE.PointLight(0xffffff, intensity, Math.max(sizeX, sizeY, sizeZ) * 2);
            topLight.position.set(centerX + 2, 3.2, centerZ); // slightly above top
            topLight.castShadow = true;

            const inferenceTopLight = topLight.clone();
            scene.add(topLight);

            // Bottom light
            const bottomLight = new THREE.PointLight(0xffffff, intensity * 0.8, Math.max(sizeX, sizeY, sizeZ) * 2);
            bottomLight.position.set(centerX - 1.5, -2, centerZ + 1); // slightly below bottom
            bottomLight.castShadow = true;
            const inferenceBottomLight = bottomLight.clone();
            scene.add(bottomLight);

            window.topLight = topLight
            window.bottomLight = bottomLight

            addLightHelper(topLight, 0.5, 0xffff00, 0.1);
            addLightHelper(bottomLight, 0.5, 0xff00ff, 0.1);

            inferenceTopLight.castShadow = true;
            inferenceBottomLight.castShadow = true;

            inferenceScene.add(inferenceTopLight);
            inferenceScene.add(inferenceBottomLight);

            // Initialize prediction scene (same setup as inference)
            predictionScene = new THREE.Scene();
            predictionScene.background = new THREE.Color(0xffffff);

            predictionCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            predictionCamera.position.set(0, 0, 3.5);
            predictionCamera.lookAt(0, 0, 0);

            predictionCanvas = document.getElementById('prediction-image');
            predictionCanvas.width = 224;
            predictionCanvas.height = 224;

            predictionRenderer = new THREE.WebGLRenderer({
                canvas: predictionCanvas,
                antialias: true,
                preserveDrawingBuffer: true
            });
            predictionRenderer.setSize(224, 224);

            // Clone lights for prediction scene
            const predictionTopLight = topLight.clone();
            predictionTopLight.castShadow = true;
            predictionScene.add(predictionTopLight);

            const predictionBottomLight = bottomLight.clone();
            predictionBottomLight.castShadow = true;
            predictionScene.add(predictionBottomLight);
        }

        // Create visual walls matching physics
        function createWalls(size) {
            // Remove existing walls
            if (wallGroup) {
                scene.remove(wallGroup);
            }

            wallGroup = new THREE.Group();
            const halfSize = size / 1.0;
            const height = 0.5;
            const thickness = 0.05;

            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x667eea,
                transparent: true,
                opacity: 0.3
            });

            // North wall (Z-)
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(halfSize * 2 + thickness * 2, height * 2, thickness * 2),
                wallMaterial
            );
            northWall.position.set(0, height, -halfSize - thickness);
            wallGroup.add(northWall);

            // South wall (Z+)
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(halfSize * 2 + thickness * 2, height * 2, thickness * 2),
                wallMaterial
            );
            southWall.position.set(0, height, halfSize + thickness);
            wallGroup.add(southWall);

            // East wall (X+)
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(thickness * 2, height * 2, halfSize * 2),
                wallMaterial
            );
            eastWall.position.set(halfSize + thickness, height, 0);
            wallGroup.add(eastWall);

            // West wall (X-)
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(thickness * 2, height * 2, halfSize * 2),
                wallMaterial
            );
            westWall.position.set(-halfSize - thickness, height, 0);
            wallGroup.add(westWall);

            scene.add(wallGroup);
        }

        // Update walls when size changes
        function updateWalls(size) {
            createWalls(size);
            simulation.updateWalls(size);
        }

        // Load GLB model
        function loadModel() {
            const loader = new GLTFLoader();
            loader.load('static/models/isotopebox.glb', (gltf) => {
                if (crateMesh) scene.remove(crateMesh);
                crateMesh = gltf.scene;
                window.crateMesh = crateMesh; // for debugging

                // 1. Calculate bounding box
                const box = new THREE.Box3().setFromObject(crateMesh);
                const size = new THREE.Vector3();
                box.getSize(size);
                const center = new THREE.Vector3();
                box.getCenter(center);

                // 2. Center the geometry
                crateMesh.traverse(node => {
                    if (node.isMesh) {
                        node.geometry.translate(-center.x, -center.y, -center.z);
                    }
                });
                crateMesh.rotation.y = Math.PI;
                // Update world matrix after centering
                crateMesh.updateMatrixWorld(true);

                console.log(`Model loaded. Size: ${size.x.toFixed(3)} x ${size.y.toFixed(3)} x ${size.z.toFixed(3)}`);

                // 3. Extract and merge ALL geometry for physics
                const allVertices = [];
                const allIndices = [];
                let vertexOffset = 0;

                crateMesh.traverse(node => {
                    if (node.isMesh) {
                        const geo = node.geometry;
                        const pos = geo.attributes.position;

                        // Add vertices (already centered)
                        for (let i = 0; i < pos.count; i++) {
                            allVertices.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                        }

                        // Add indices with offset
                        if (geo.index) {
                            const indices = geo.index.array;
                            for (let i = 0; i < indices.length; i++) {
                                allIndices.push(indices[i] + vertexOffset);
                            }
                        } else {
                            // Non-indexed geometry
                            for (let i = 0; i < pos.count; i++) {
                                allIndices.push(i + vertexOffset);
                            }
                        }

                        vertexOffset += pos.count;

                        console.log(`  Mesh part: ${pos.count} vertices, ${geo.index ? geo.index.count / 3 : pos.count / 3} triangles`);
                    }
                });
                crateMesh.position.set(0, 1.5, 0);

                if (allVertices.length > 0) {
                    console.log(`Total merged mesh: ${allVertices.length / 3} vertices, ${allIndices.length / 3} triangles`);
                    simulation.setMeshShape(allVertices, allIndices);

                    // Create merged debug mesh
                    if (debugMesh) scene.remove(debugMesh);
                    const mergedGeo = new THREE.BufferGeometry();
                    mergedGeo.setAttribute('position', new THREE.Float32BufferAttribute(allVertices, 3));
                    mergedGeo.setIndex(allIndices);
                    debugMesh = new THREE.Mesh(
                        mergedGeo,
                        new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
                    );
                    scene.add(debugMesh);
                } else {
                    console.warn('No mesh found for physics, falling back to box');
                    simulation.setBoxSize(size.x / 2, size.y / 2, size.z / 2);

                    // Fallback debug mesh
                    if (debugMesh) scene.remove(debugMesh);
                    debugMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(size.x, size.y, size.z),
                        new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
                    );
                    scene.add(debugMesh);
                }

                const axes = new THREE.AxesHelper(5);
                crateMesh.add(axes);

                crateMesh.scale.set(1.0, 1.0, 1.0);
                crateMesh.traverse(c => {
                    if (c.isMesh) {
                        c.castShadow = true;
                        c.receiveShadow = true;
                    }
                });
                scene.add(crateMesh);

                // 4. Create inference crate - DON'T copy child rotations!
                inferenceCrate = new THREE.Group();
                crateMesh.traverse(node => {
                    if (node.isMesh) {
                        const clone = new THREE.Mesh(node.geometry.clone(), node.material.clone());
                        clone.position.copy(node.position);
                        // DON'T copy rotation - let parent group control it
                        clone.scale.copy(node.scale);
                        inferenceCrate.add(clone);
                    }
                });
                // Apply the base rotation to the group instead
                inferenceCrate.rotation.y = Math.PI;
                inferenceScene.add(inferenceCrate);

                // 5. Create prediction crate - DON'T copy child rotations!
                predictionCrate = new THREE.Group();
                crateMesh.traverse(node => {
                    if (node.isMesh) {
                        const clone = new THREE.Mesh(node.geometry.clone(), node.material.clone());
                        clone.position.copy(node.position);
                        // DON'T copy rotation - let parent group control it
                        clone.scale.copy(node.scale);
                        predictionCrate.add(clone);
                    }
                });
                // Apply the base rotation to the group instead
                predictionCrate.rotation.y = Math.PI;
                predictionScene.add(predictionCrate);
            });
        }

        function quatCosineLoss(pred, actual) {
            // pred = [x,y,z,w]
            // actual = [x,y,z,w]

            // Normalize (your model normalizes, but safe)
            const np = normQuat(pred);
            const na = normQuat(actual);

            // dot product
            const dot =
                np[0] * na[0] +
                np[1] * na[1] +
                np[2] * na[2] +
                np[3] * na[3];

            // cosine loss from training
            return 1.0 - Math.abs(dot);
        }

        function normQuat(q) {
            const n = Math.sqrt(q[0] ** 2 + q[1] ** 2 + q[2] ** 2 + q[3] ** 2) + 1e-8;
            return [q[0] / n, q[1] / n, q[2] / n, q[3] / n,];
        }


        // UI Controls
        document.getElementById('start-btn').addEventListener('click', () => {
            simulation.start();
            document.getElementById('start-btn').disabled = true;
            document.getElementById('stop-btn').disabled = false;
        });

        document.getElementById('stop-btn').addEventListener('click', () => {
            simulation.stop();
            document.getElementById('start-btn').disabled = false;
            document.getElementById('stop-btn').disabled = true;
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            simulation.reset();
        });

        document.getElementById('rl-enabled-check').addEventListener('change', (e) => {
            simulation.setRLEnabled(e.target.checked);
        });

        document.getElementById('wall-size-slider').addEventListener('input', (e) => {
            const size = parseFloat(e.target.value);
            document.getElementById('wall-size-val').textContent = size.toFixed(1);
            updateWalls(size);
        });

        document.getElementById('save-inference-btn').addEventListener('click', () => {
            window.saveNextInferenceImage = true;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });



        // Simulation callbacks
        simulation.onStateUpdate = (state) => {
            crateMesh.position.set(...state.position);
            crateMesh.quaternion.set(...state.quaternion);

            simulation.lastQuaternion = state.quaternion;

            const infermang = new InferenceManager()

            // Convert to Blender format for display
            const blenderQuat = infermang.threeToBlenderQuat(state.quaternion);
            document.getElementById('actual-quat').textContent =
                `x:${blenderQuat[0].toFixed(3)}, y:${blenderQuat[1].toFixed(3)}, z:${blenderQuat[2].toFixed(3)}, w:${blenderQuat[3].toFixed(3)}`;

            const euler = quatToEulerDegrees(state.quaternion);
            document.getElementById('actual-euler').textContent =
                `[${euler.map(v => v.toFixed(1)).join(', ')}]`;

            if (debugMesh) {
                debugMesh.position.copy(crateMesh.position);
                debugMesh.quaternion.copy(crateMesh.quaternion);
            }

            const actualEuler = quatToEulerDegrees(state.quaternion);
            document.getElementById('actual-euler').textContent =
                `[${actualEuler.map(v => v.toFixed(1)).join(', ')}]`;


            document.getElementById('pos-x-val').textContent = state.position[0].toFixed(2);
            document.getElementById('pos-y-val').textContent = state.position[1].toFixed(2);
            document.getElementById('pos-z-val').textContent = state.position[2].toFixed(2);
            document.getElementById('step-count').textContent = state.step_count;
            document.getElementById('actual-quat').textContent =
                `[${state.quaternion.map(v => v.toFixed(3)).join(', ')}]`;

            if (state.action) {
                document.getElementById('rl-action').textContent =
                    `[${state.action.map(v => v.toFixed(3)).join(', ')}]`;
            }
        };



        simulation.onInferenceUpdate = (result) => {
            const predQuat = result.quaternion; // In Three.js format [x,y,z,w]
            //console.log('ðŸ”® Inference update - predQuat (Three.js):', predQuat);
            // Update predicted quat display with labels
            document.getElementById('predicted-quat').textContent =
                `x:${predQuat[0].toFixed(3)}, y:${predQuat[1].toFixed(3)}, z:${predQuat[2].toFixed(3)}, w:${predQuat[3].toFixed(3)}`;

            const predEuler = quatToEulerDegrees(predQuat);
            document.getElementById('pred-euler').textContent =
                `[${predEuler.map(v => v.toFixed(1)).join(', ')}]`;

            // Get actual quat from simulation loop
            // Get actual quat from simulation loop and convert to Blender format

            const infermang = new InferenceManager()
            const actualQuat = infermang.threeToBlenderQuat(simulation.lastQuaternion);
            if (!actualQuat) {
                console.warn("Actual quaternion not set yet.");
                return;
            }

            // Angular distance (Â°)
            const angle = quaternionAngularDistance(predQuat, actualQuat);
            document.getElementById("quat-loss").textContent = angle.toFixed(2);

            // Cosine loss
            const cos = quatCosineLoss(predQuat, actualQuat);
            document.getElementById("cos-loss").textContent = cos.toFixed(6);

            // Update prediction crate orientation
            if (predictionCrate) {
                //console.log('ðŸ“¦ Updating prediction crate with quaternion:', predQuat);
                predictionCrate.quaternion.set(predQuat[0], predQuat[1], predQuat[2], predQuat[3]);
            } else {
                console.warn('âš ï¸ predictionCrate not initialized yet');
            }
        };

        // Mouse interaction for ragdoll physics
        function getMouseWorldPoint(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (crateMesh) {
                const distance = camera.position.distanceTo(crateMesh.position);
                const worldPoint = new THREE.Vector3();
                worldPoint.copy(raycaster.ray.origin).add(
                    raycaster.ray.direction.clone().multiplyScalar(distance)
                );
                return [worldPoint.x, worldPoint.y, worldPoint.z];
            }
            return null;
        }

        function initInput() {
            renderer.domElement.addEventListener('mousedown', (event) => {
                if (!simulation.isRunning) return;

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(crateMesh, true);

                if (intersects.length > 0) {
                    isDragging = true;
                    controls.enabled = false;
                    const point = intersects[0].point;
                    simulation.grabBox([point.x, point.y, point.z]);
                }
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                const worldPoint = getMouseWorldPoint(event);
                if (worldPoint) {
                    simulation.moveGrabbed(worldPoint);
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    controls.enabled = true;
                    simulation.releaseBox();
                }
            });

            renderer.domElement.addEventListener('mouseleave', () => {
                if (isDragging) {
                    isDragging = false;
                    controls.enabled = true;
                    simulation.releaseBox();
                }
            });
        }

        // Animation loop
        async function animate() {
            requestAnimationFrame(animate);

            if (simulation.isRunning && inferenceCrate && predictionCrate) {
                // Update inference crate to match current pose BEFORE rendering
                inferenceCrate.position.set(0, 0, 0);
                inferenceCrate.quaternion.copy(crateMesh.quaternion);
                inferenceCrate.scale.copy(crateMesh.scale);

                // Render inference scene BEFORE capturing for inference
                inferenceRenderer.render(inferenceScene, inferenceCamera);

                // Update prediction crate position (rotation is set by onInferenceUpdate)
                predictionCrate.position.set(0, 0, 0);
                predictionCrate.scale.copy(crateMesh.scale);

                // Render prediction scene
                predictionRenderer.render(predictionScene, predictionCamera);

                // Now run simulation step (which may capture the inference canvas)
                await simulation.step(inferenceRenderer, INFERENCE_INTERVAL);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize
        async function init() {
            try {
                updateLoadingStatus('Initializing scene...');
                initScene();
                initInferenceScene();
                initInput();
                loadModel();
                createWalls(1.0);

                updateLoadingStatus('Loading ONNX models...');
                await simulation.initialize();

                updateLoadingStatus('Ready!');
                hideLoadingOverlay();

                animate();
            } catch (error) {
                console.error('Initialization error:', error);
                updateLoadingStatus('Error: ' + error.message);
            }
        }

        init();
    </script>
</body>

</html>